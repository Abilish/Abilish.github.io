
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Do">
    <title>Docker学习笔记 - Do</title>
    <meta name="author" content="Abilish">
    
    
        <link rel="icon" href="http://example.com/assets/images/avatar.png">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Abilish","sameAs":["https://github.com/abilish","http://stackoverflow.com/users"],"image":"avatar.png"},"articleBody":"\n\n\n\n\n\n一、Docker 简介根据百度百科的介绍：\n\nDocker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux或Windows操作系统的机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。\n\nDocker采用的是Go语言编写的，该语言一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言，常用于Web程序开发，并且具有成熟的Web开发框架，如Beego、Gin、Iris等等。\nGo语言描述\nGo的语法接近C语言，但对于变量的声明有所不同。Go支持垃圾回收功能。\n二、Docker 概述和常用命令1. Docker 整体理解\ndocker解决问题：项目带上环境安装打包，可以跨平台（windows–&gt;Linux）\nDocker和VM对比：\nVmware，虚拟电脑，很笨重，属于虚拟化技术\n​    dockers容器技术也是一种虚拟化技术\ndocker：隔离，镜像（最核心的环境）十分小巧\n\n传统虚拟机，虚拟出一套硬件，运行一个完整的操作系统，然后在这个操作系统上安装和运行软件\n容器内的应用直接运行在宿主机的内核上，容器没有自己的内核，也没有虚拟硬件，因此更为轻便。每个容器之间是互相隔离的，每个容器内都有一个属于自己的文件系统，且互不影响\n\nDocker有着比虚拟机更少的抽象层。\n\nDocker利用的是宿主机的内核，VM用的是Guest OS，因此，新建容器时，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。VM是分钟级的，docker是秒级的\n\n学习路径：先学会传统虚拟机上如何部署环境，再学习Docker\n概述：基于Go语言开发，开源\n\n镜像(Image)：镜像是一个原始模板，通过模板来创建容器\n容器(container)：容器是来提供服务的。启动，停止，删除等等\n仓库(repository)：仓库是用来存放镜像的地方，类似与github、gitee等等，分为共有私有。docker hub 在国外，需要配置国内的镜像加速。\n**安装基本步骤(cnetos8)**：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657581. 卸载旧版本sudo yum remove docker \\                  docker-client \\                  docker-client-latest \\                  docker-common \\                  docker-latest \\                  docker-latest-logrotate \\                  docker-logrotate \\                  docker-engine2. 安装相关依赖sudo yum install -y yum-utils3. 设置国内yum镜像源国外源：sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo阿里云国内源安装docker：sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo4. 更新yum软件包索引centos8 无fast参数：yum makecacheyum makecache fast5. 安装docker最新版的安装方式(2023/2/18)：docker-ce社区版；docker-ee企业版sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin一路按 y6. 启动dockersudo systemctl start docker7. 验证安装成功docker version8. 通过启动镜像验证安装成功sudo docker run hello-world9. 查看镜像是否已经被下载docker images10. 卸载dockera. 卸载依赖sudo yum remove docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extrasb. 删除资源sudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd11. 设置阿里云docker镜像加速登录阿里云官方，找到“容器镜像服务”--&gt; 镜像工具 --&gt; 镜像加速器选择所使用的操作系统，按照步骤来配置，下面的命令依次敲：sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [&quot;https://自己的仓库地址，你猜.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker\n\nDocker是一个Client-Server结构的系统，Docker的守护进程运行在主机上通过Socket从客户端访问。DockerServer接收到Docker-Client的指令就会执行。容器内的端口映射到宿主机的端口。\n\n2. 辅助命令及学习网站docker官网\ndocker hub  仓库地址\n123456# 查看操作系统的发行版号uname -r  # 显示系统名、节点名称、操作系统的发行版号、内核版本等等uname -a # 查看虚拟机系统版本信息cat /etc/os-release\n\n帮助命令：\n123456# 显示docker的版本信息docker version# 显示docker系统信息，包括镜像和容器的数量docker info# 帮助万能命令docker 命令 --help  \n\ndocker命令帮助文档地址：https://docs.docker.com/reference/\n菜鸟教程中文地址：Docker 命令大全 | 菜鸟教程 (runoob.com)\n3. 镜像命令docker images 查看镜像\n1234docker images# 常用参数-a, --all             Show all images (default hides intermediate images)-q, --quiet           Only show image IDs\n\na. 通过官方文档来学习命令：https://docs.docker.com/engine/reference/commandline/images/\nb. 通过help来学习docker images --help\n1234# 相当于在docker hub上搜索docker search mysql # 过滤出收藏量大于3000的，且展示详细信息docker search mysql --filter=STARS=3000 --no-trunc\n\n\n\n12# 列出images完整iddocker images --no-trunc\n\n\n\ndocker pull 下载镜像\n1docker pull 镜像名:tag\n\n不写tag默认下载最新版本，docker images 分层下载，是image的核心，联合文件系统。\npull中的design是签名，最后一行为真实地址\n123# pull mysql等价于从真实地址去拉取docker pull mysqldocker pull docker.io/library/mysql:latest\n\n\n\ndocker rmi 删除镜像\n1234docker rmi -f 镜像iddocker rmi repository:tag# 删除所有镜像docker rmi -f $(docker images -aq)\n\n\n\n\n\n4. 容器命令前提，先pull一个镜像\n1docker pull centos\n\n\n\ndocker run 启动容器\ndocker run | Docker Documentation\n12345678910111213docker run [OPTIONS] IMAGE [COMMAND] [ARG...]# 如果没有下载启动时会自动下载，默认下载最新版本# 常用参数--name 给容器命名-d     后台方式启动(后台运行时如果没有前台进程，docker发现没有应用就会自动停止)-i     交互式操作-t     终端-p     指定容器的端口，将容器端口映射到主机  -p 8080：8080\t-p 主机端口:容器端口   （最常用的一种方式）\t-p 容器端口\t容器端口\tip ip:主机端口:容器端口-P     大写的P是随机指定端口\n\n启动一个容器: \n1docker run -it centos /bin/bash\n\n非后台启动，退出命令为：exit\n123456# 列出正在运行的容器docker ps# 常用参数-a    列出所有，包括历史曾运行过的容器-n=1  只显示最近的一个-q    只显示容器的编号\n\n退出容器\n1234# 直接停止并退出exit# 容器不停止退出Ctrl + P + Q\n\n删除容器\n123456# 删除指定容器docker rm 容器id# 删除所有的容器docker rm -f $(docker ps -aq)# 通过管道符过滤删除docker ps -a -q|xargs docker rm\n\n启动容器\n 12345678# 启动容器docker start 容器id# 重启容器docker restart 容器id# 停止当前正在运行的容器docker stop 容器id# 强制停止当前容器docker kill 容器id\n\n\n\n5 常用命令汇总查看日志：\ndocker logs | Docker Documentation\n12345docker logs 容器id# 常用参数-f : 跟踪日志输出，持续输出日志内容-t : 显示时间戳--tail/-n :仅列出最新N条容器日志  -n 15\n\n\n\n123456# shell 脚本&quot;while true;do echo docker;sleep 1;done&quot;# 重新启动一个容器，运行shell脚本，使其不断打印，产生日志docker run -d centos /bin/sh -c &quot;while true;do echo docker;sleep 1;done&quot;# 查看容器日志docker logs -t -f -n 10 71f8b56ac14e\n\n\n\n查看容器中的进程信息\n12345docker top 容器id# 显示UID  用户IDPID  父IDPPID 进程ID\n\n\n\n查看镜像的元数据\n1docker inspect 容器id\n\n\n\n进入当前正在运行的容器\n12345# 进入容器后开启新终端（常用）docker exec -it 容器id/name bashShell# 例：docker exec -it 71f8b56ac14e /bin/bash\n\n\n\n123# 进入容器正在执行的终端，不会启动新的进程docker attach 容器id# Attach local standard input, output, and error streams to a running container\n\n\n\n从容器内拷贝文件到主机\n123docker cp 容器id:容器内路径 目的的主机路径docker cp 9d140e95797a:/home/a.txt /home\n\n\n\n官方图：\n\n6 Docker 镜像理解镜像是独立的软件包\nDocker镜像加载原理为**UnionFS (联合文件系统)**，镜像可以通过分层来进行继承，基于基础镜像，制作复制具体的应用镜像。\ndocker的镜像实际上有一层一层的文件系统组成，这种层级的文件系统就是UnionFS。\nbootfs(boot file system) linux刚启动时会加载bootfs文件系统，Dcker也是一样的，加载完成后整个内核就在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs\nrootfs(root file system) ，在bootfs之上。包含的就是典型Linux系统中的 /dev, /proc, /bin, /etc 等标准目录和文件，rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等\n为什么Docker中的centos很小？\n因为rootfs中只包含了最基本的命令、工具和程序库，直接用的是主机的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。\n分层\n分层进行复用。\nDocker的镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层就是我们说的容器层，容器之下只读，无法改变的部分都叫做镜像层。\n7 commit镜像123docker commit 提交容器成为一个新的副本docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG]\n\n123456项目练习2 拷贝tomcat基本镜像docker commit -a=&quot;Abilish&quot; -m=&quot;add webapps app&quot; 236dffd55cf1 tomcat02:1.0# 查看自己提交的镜像docker images \n\n\n\n\n\n\n\n三、Docker 进阶0 可视化管理dockerportainer\n1docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer\n\n设置登录密码，选择本地(local)\nRancher(CI/CD)\n1待补充\n\n\n\n\n\n挂载分为使用命令挂载，以及用DockerFile挂载两种方式。\n1. 容器数据卷产生原因：数据和容器分离，数据单独独立，持久化保存。\nMySQL数据可以存储在本地。容器之间可以有一个数据共享的技术。Docker 容器中产生的数据剋同步到本地，因此产生了目录挂载。目录挂载就是容器内和容器外连接的目录是同步更新的。\n方式一：使用命令挂载\n1234567891011121314151617docker run -it -v 主机目录:容器目录docker run -it -v /home/test:/home centos /bin/bash# 可以查看到容器的挂载信息docker inspect 容器id......        &quot;Mounts&quot;: [            &#123;                &quot;Type&quot;: &quot;bind&quot;,                &quot;Source&quot;: &quot;/home/test&quot;,                &quot;Destination&quot;: &quot;/home&quot;,                &quot;Mode&quot;: &quot;&quot;,                &quot;RW&quot;: true,                &quot;Propagation&quot;: &quot;rprivate&quot;            &#125;......# 容器删除，本机上挂载的数据依旧存在\n\n\n\n具名挂载和匿名挂载\n12345678910111213141516171819202122232425# 匿名挂载：只写容器内名字不写容器外名字-v 容器内路径docker run -d -P --name nginx01 -v /etc/nginx nginx# 查看本地所有的卷的情况，显示的是没有名字的这就是匿名挂载docker volume ls# 具名挂载docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginxdocker volume ls# 可以看到挂载的名字为 juming-nginx# 查看这个卷的位置docker volume inspect juming-nginx    &#123;        &quot;CreatedAt&quot;: &quot;2023-02-22T22:48:38+08:00&quot;,        &quot;Driver&quot;: &quot;local&quot;,        &quot;Labels&quot;: null,        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;,  # 此参数为挂载的目录位置        &quot;Name&quot;: &quot;juming-nginx&quot;,        &quot;Options&quot;: null,        &quot;Scope&quot;: &quot;local&quot;    &#125;    # 在没有指定目录的情况下，基本所有的卷都在这个位置 /var/lib/docker/volumes/卷名/_data\n\ndocker volume –help\n总结：挂载的方式总共分为三种，指定路径挂载、匿名挂载、具名挂载\n其他：\n12345678# 挂载目录后面加上 ro 或者 rw# ro 表示 read only 只读# rw 表示 read write 可读可写# 默认为 rw# 设置的容器权限。如果是 ro ，那么在容器内部是只读的，无法改变，只能通过宿主机改变docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx\n\n\n\n\n\n2. DockerFile 构建镜像挂载方式二：\nDockerfile 就是用来构建 docker 镜像的构建文件，是命令脚本，通过这个脚本可以生成镜像，镜像是一层一层的，脚本是一个一个命令，每个命令都是一层。\n123456789101112131415161718192021222324252627# 1 新建一个dockerfile01文件，编辑，写入如下的命令：FROM centosVOLUME [&quot;volume01&quot;,&quot;volume02&quot;]CMD echo &quot;----end----&quot;CMD /bin/bash# 文件中的内容，或者指令都是大写的# 2 docker build 命令构建镜像docker build -f dockerfile01 -t abilish/centos:1.0 .# 常用参数-f   file文件名-t   生成的镜像及标签名 Name and optionally a tag in the name:tag format# 3 执行后可以看到成功生成的镜像docker images# 4 启动镜像docker run -it afa669b6bce7 /bin/bashls# 可以看到其中的两个目录：volume01、volume02，这两个目录就是刚刚挂载的目录docker inspect 容器id# 可以查到主机中挂载的位置\n\n如果在构建镜像时没有设置挂载，那么需要在启动镜像时设置 -v 挂载参数\n数据卷容器多个容器之间实现数据同步\n被挂载的叫做父容器\n12345678910111213--volumes-from docker run -it --name docker01 abilish/centos:1.0# 启动第二个镜像并进行挂载docker run -it --name docker02 --volumes-from docker01  abilish/centos:1.0# volume01、volume02 镜像之间会同步更新docker run -it --name docker03 --volumes-from docker01  abilish/centos:1.0# 停止父容器，在其他容器中（docker02、docker03）挂载目录依旧同步，# 其他的容器中之前创建的文件不会消失# 删除父容器，docker02、docker03 之间挂载目录的数据依旧时同步的docker rm -f docker01\n\n\n\n问题(待解决)：如果两个容器有不同数量的挂载目录呢？如果挂载之前每个容器中有不同的数据，能合并吗？\n同理，mysql中也就可以实现数据同步了\n容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止\n但是一但持久化到了本地，就可以持久化保存了\nDockerFile概念：dockerfile 是用来构建docker镜像的文件，命令参数脚本\n构建步骤：\n1、编写一个 dockerfile 文件\n2、docker build 构建成为一个镜像\n3、docker run 运行镜像\n4、docker push 发布镜像（DockerHub或者阿里云镜像库）\ncentos为例：\nsig-cloud-instance-images/Dockerfile at b2d195220e1c5b181427c3172829c23ab9cd27eb · CentOS/sig-cloud-instance-images (github.com)\n123456789101112131415FROM scratchADD centos-7-x86_64-docker.tar.xz /LABEL \\    org.label-schema.schema-version=&quot;1.0&quot; \\    org.label-schema.name=&quot;CentOS Base Image&quot; \\    org.label-schema.vendor=&quot;CentOS&quot; \\    org.label-schema.license=&quot;GPLv2&quot; \\    org.label-schema.build-date=&quot;20201113&quot; \\    org.opencontainers.image.title=&quot;CentOS Base Image&quot; \\    org.opencontainers.image.vendor=&quot;CentOS&quot; \\    org.opencontainers.image.licenses=&quot;GPL-2.0-only&quot; \\    org.opencontainers.image.created=&quot;2020-11-13 00:00:00+00:00&quot;CMD [&quot;/bin/bash&quot;]\n\n大多数官方的镜像都是基础包，用户需要自定义搭建镜像\nDockerFile 构建过程及指令基础知识：\n1、每个保留关键字(指令)都必须是大写字母\n2、执行从上到下顺序执行\n3、# 表示注释\n4、每一个指令都会创建提交一个新的镜像层\nDockerFile 是面向开发的，用来发布项目，做镜像\n指令\n123456789101112FROM        # 基础镜像MAINTAINER  # 镜像是谁写的，维护者信息，姓名+邮箱RUN         # 镜像构建的时候需要运行的命令ADD         # 步骤，tomcat镜像，上传压缩包，会自动解压WORKDIR     # 镜像的工作目录VOLUME      # 挂载的目录EXPOSE      # 指定端口，这里写了就不用指定 -p 了CMD         # 指定这个容器启动的时候要运行的命令，是替换命令行中的命令ENTRYPOINT  # 指定这个容器启动的时候要运行的命令，是在命令行命令后追加命令ONBUILD     # 当构建一个被继承 DockerFile 这个时候就会运行 ONBUILD 的指令，触发指令。COPY        # 类似 ADD ，将我们文件拷贝到镜像中ENV         # 构建的时候设置环境变量\n\n\n\n\n\n12# 查看构建历史docker history 镜像id\n\n\n\nCMD 和 ENTRYPOINT 的区别1234567891011121314151617181920212223242526272829CMD         # 指定这个容器启动的时候要运行的命令，是替换命令行中的命令ENTRYPOINT  # 指定这个容器启动的时候要运行的命令，是在命令行命令后追加命令vim dockerfile-cmd-testFROM centosCMD [&quot;ls&quot;, &quot;-a&quot;]docker build -f dockerfile-cmd-test -t cmdtest .# run 这个容器后会输出当前目录，这是因为DockerFile中增加了CMD命令docker run cmdtest# 如果在run时增加-l参数，-l会替换 CMD [&quot;ls&quot;, &quot;-a&quot;] 命令，-l不是命令所以会报错docker run cmdtest -l# 正确的方式为：docker run cmdtest ls -alvim dockerfile-cmd-entrypointFROM centosENTRYPOINT [&quot;ls&quot;, &quot;-a&quot;]docker build -f dockerfile-cmd-entrypoint -t entorypoint-test .# 可以执行成功，并且输出 ls -al 的结果docker run b40785390900 -l\n\n\n\n\n\n\n\nDockerFile ：构建文件，定义了一切的步骤，源代码\nDockerImages ：通过 DockerFile 构建生成的镜像，最终发布和运行的产品\nDocker容器 ：容器是镜像运行起来提供服务的\n3.Docker 网络原理Docker0123456# 查看网卡ip addr结果：lo 本机回环地址eth0 内网地址docker0 docker网卡地址，桥接模式，使用的技术是 veth-pair 技术\n\nDocker 中的网络访问\n12345678910111213141516docker exec -it tomcat_net ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever76: eth0@if77: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever       # 可以看到容器启动的时候会得到一个 eth0@  的ip地址，这是dockers分配的ip地址。ping 172.17.0.2# Linux是可以ping通docker容器内部的容器带来的网卡都是成对出现的，veth-pair 技术，是一对的虚拟设备接口，一端连着协议，一端彼此相连。veth-pair 充当一个桥梁，连接各种虚拟网络设备的。# 不同容器之前是可以互相ping通的\n\n\n\n1234567891011# docker0 相当于是路由器，转发消息，不同容器共用一个路由器# 所有的容器不指定网络的情况下，都是 docker0 路由的，docker会给我们的容器分配一个默认的可用 IP# 只要容器删除，对应的网桥就没了255.255.0.1/16正常的地址：00000000.00000000.00000000.00000000十进制：255.255.255.255一个路由下：255.255.0.0  255*255-0.0.0.0(回环地址)-255.255.255.255(最终地址)=65535255.255.0.1/24  域 局域网，一般小教室是24，公司是16\n\n\n\n\n容器互联–link （入门互联 通过名字ping通两个容器）启动两个tomcat：\n12docker run -d -P --name tomcat01 tomcatdocker run -d -P --name tomcat02 tomcat\n\n直接通过名字ping是无法ping通的\n12docker exec -it tomcat02 ping tomcat01OCI runtime exec failed: exec failed: unable to start container process: exec: &quot;ping&quot;: executable file not found in $PATH: unknown\n\n创建容器时通过 –link 参数来 link 另一个容器\n1docker run -d -P --name tomcat03 --link tomcat02 tomcat\n\n通过 --link 参数建立连接后，只能从03的方向ping 02，反过来是ping不通的\n1docker exec -it tomcat03 ping tomcat02\n\n如果在容器启动时进行了link，但被link的容器删除掉，即使再创建一个同名的容器也是无法ping通的\ndocker network 命令\n123456789101112131415docker network -helpdocker network lsNETWORK ID     NAME      DRIVER    SCOPEd50b0dcbbc57   bridge    bridge    localeeea9a40175b   host      host      local8460731336c8   none      null      local# 查看网络信息docker network inspect d50b0dcbbc57# 使用下面的命令可以找到 &quot;Links&quot; 参数，存放了link的信息docker inspect 容器id# 或者通过第二种方式查看，在hosts文件中增加了一个映射docker exec -it tomcat03 cat /etc/hosts...172.17.0.5\ttomcat02 606ae16ac1bd...\n\n\n\n自定义网络(高级互联)查看所有的网络\n1docker network ls\n\n\n\n网络模式\n**bridge(桥接模式)**：搭桥，通过 0.1 可以访问 0.2 和 0.3 ，0.1起到转发的作用。docker默认使用桥接模式，自己创建的网络也使用桥接模式\nnone(不配置网络)\n**host(主机模式)**：和宿主机共享网络\ncontainer(容器内网络连通)：用的较少，局限很大\n默认网络直接启动时时可以指定参数，bridge 就是docker0的网络\n1docker run -d -P --name tomcat01 --net bridge diytomcat\n\ndocker0的特点：\n\n–net 默认走docker0\n域名不能访问，–link可以打通连接\n\n自定义网络123456789101112131415161718docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet# 常用参数--driver: 指定网络模式，bridge 桥接模式--subnet：子网，192.168.0.0/16，16时65535个子网，如果为24，那么只能创建255个--gateway：指定网关，从哪里出去# ls查看一下，即可看到创建的网络 mynetdocker network ls2e4276da5434   mynet     bridge    local# 启动一个使用自定义网络的容器docker run -d -P --name tomcat-net-01 --net mynet diytomcatdocker run -d -P --name tomcat-net-02 --net mynet diytomcat# 查看网络状态docker network inspect mynet# 使用自定义的网络是可以 ping 通的 docker exec -it tomcat-net-01 ping tomcat-net-02docker exec -it tomcat-net-02 ping tomcat-net-01\n\n自定义的网络docker0已经维护好了对应的关系，功能更加完善，无需指定–link参数。\n不同的集群使用不同的网络，保证集群是安全和健康的\n网络连通在docker0网络中启动两个容器\n12docker run -d -P --name tomcat1 diytomcatdocker run -d -P --name tomcat2 diytomcat\n\n连接容器tomcat1到网络mynet\n1docker network connect mynet tomcat1\n\n此时，两个方向来ping是可以ping通的了\n实际上，tomcat1是被加入到了mynet网络中，这就是一个容器两个ip地址\n1docker network inspect mynet\n\n\n\n\n\n4.IDEA 整合 Docker5.Docker Compose  集群管理6. Docker Swarm 容器编排7.CI/CD jenkins四、深入理解Docker读文档1、\n\ndocker layer 是什么？\nWhat is docker layer? importance of docker layer while creating Dockerfile (naiveskill.com)\n看完这篇文章后我的简单理解：docker layer 是 dockerfiles 创建时的每一层，每一层对应完成fockerfiles的一个动作，dockerfiles总的来看分成了两个动作：base image；基于base image的layers\n\n层数越多，所占用的空间就越多，因此可以通过减少层数来降低所占用的空间\n五、项目练习1 Docker 部署Nginx12345678910111213# 1 搜索nginx： a.docker search   b.到 docker hub 上搜索https://hub.docker.com/_/nginxdocker pull nginx# 服务器开放3344端口，容器内在80端口，通过公网3344可以访问到容器内部docker run -d --name nginx01 -p 3344:80 nginx# 运行测试curl localhost:3344# 进入容器docker exec -it nginx01 /bin/bash# 找nginx的配置文件位置(有很多，都是做什么的呢？)whereis nginxcd /etc/nginx# 其中 nginx.conf 使nginx的配置文件\n\n\n\n问题：每次改动nginx配置文件都一定需要进入容器吗？—&gt;数据卷\n2 使用docker来装一个tomcat123456789101112docker run -it --rm tomcat:9.0# --rm参数，用完即删docker pull tomcatdocker run -d -p 8080:8080 tomcat:latest# 指定开放的端口后，外网可以访问到，但提示404，因为官方所给的tomcat不是完整版# 进入容器docker exec -it b9b74f7a705d /bin/bash# 发现问题：1 Linux命令少了  2 没有webapps# 阿里云镜像原因，默认为最小镜像，所有不必要的都剔除掉# 将webapps.dist 复制过去就可以访问了cp -r webapps.dist/* webapps\n\n\n\n3 部署 es + kibanaelasticsearch - Official Image | Docker Hub\n123456789101112131415161718# es 暴露的端口很多# es 十分耗内存# es 的数据一般要放在安全目录，挂载# --net somenetwork 网络配置# 启动完整版命令：docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:tagdocker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:8.6.1# 验证安装成功curl localhost:9200# 查看cpu状态docker stats# 过于占用内存，直接卡死了，修改配置文件，-e修改环境docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:8.6.1\n\n\n\n4 安装并挂载mysqlmysql - Official Image | Docker Hub\n12345678# 1 拉取镜像docker pull mysql:5.7# 2 挂载镜像，注意mysql需要设置密码docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag# 增加多个挂载版本的命令docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7# 启动成功后即可访问# 容器删除，本机上挂载的数据依旧存在\n\n\n\n5 DockerFile 构建镜像12345678910111213141516171819202122232425262728293031323334353637383940# 创建一个文件夹mkdir dockerfilecd dockerfilevim mydockerfile-centos# 填写构建镜像内容# 基础镜像centos，设置环境变量和工作路径，开放80端口，安装vim。net工具# 因为centos已经停止维护了，所以运行到 yum install 这里会卡住，需要加上修改镜像源的命令，yum makecache这一步会很慢，我更了大概有4分钟多，需要耐心等待。# 但是会自动更新版本！最后构建出来的镜像特别大，正在找解决方法(待解决)FROM centosMAINTAINER abilish&lt;sfy_mx@163.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN cd /etc/yum.repos.d/RUN sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*RUN sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*RUN yum makecacheRUN yum update -yRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;----end----&quot;CMD /bin/bash# build 构建docker build -f mydockerfile-centos -t mycentos:1.0 .# 查看构建好的镜像docker images# 运行docker -it mycentos:1.0# 查看构建变更历史docker history\n\n问题待解决，镜像换源后如何不自动更新\n6 tomcat 镜像1、准备镜像文件 tomcat压缩包，jdk的压缩包\njdk-8u151-linux-x64.tar.gz\napache-tomcat-9.0.72.tar.gz\n链接：https://pan.baidu.com/s/1Zbe2JcOVYX-b1YPQhL3cgw?pwd=8888提取码：8888 \n1touch readme.txt\n\n\n\n2、编写dockerfile文件\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116# Dockerfile 是官方命名，build时会自动找这个名字的文件，不用指定-f参数了vim Dockerfile# Dockerfile 文件中的内容，ADD后会自动解压文件FROM centosMAINTAINER abilish&lt;sfy_mx@163.com&gt;COPY readme.txt /usr/local/readme.txtADD jdk-8u151-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.72.tar.gz /usr/local/RUN cd /etc/yum.repos.d/RUN sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*RUN sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*RUN yum makecacheRUN yum update -yRUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_151ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.72ENV CATALINE_BASE /usr/local/apache-tomcat-9.0.72ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.72/bin/startup.sh &amp;&amp; tail -F /url/local/apache-tomcat-9.0.72/bin/logs/catalina.out# 构建镜像docker build -t diytomcat .# 运行镜像# 挂载目录是上面存放jdk、apache等文件目录下的目录docker run -d -p 9090:8080 --name abilishtomcat -v /home/tomcat-jdk/test:/usr/local/apache-tomcat-9.0.72/webapps/test -v /home/tomcat-jdk/tomcatlogs/:/usr/local/apache-tomcat-9.0.72/logs diytomcat# 进入容器docker exec -it 镜像id /bin/bash# 访问 ip:9090 # 发布项目(由于做了卷挂载，直接在本地编写项目就可以发布了)cd /home/tomcat-jdk/testmkdir WEB-INFcd WEB-INFvim web.xml# 写入&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;    &lt;/web-app&gt;# cd 到上一层目录cd ..vim index.jsp&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;啦啦啦啦啦&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;br/&gt;&lt;%System.out.println(&quot;---my test web log---&quot;);%&gt;&lt;/body&gt;&lt;/html&gt;# 访问 ip地址:9090/test/# 查看日志是否打印出来了cd ..cat catalina.out# 可以看到输出的 ---my test web log---  日志# 项目部署成功并且能成功访问# 发布镜像# 发布到官方镜像库中1 注册自己的账号：https://hub.docker.com/2 确定账号可以登录3 在服务器上提交镜像docker login --help\t# 常用参数\t\t-u 指定昵称\t\t-p 指定密码4 登录后 docker pushdocker tag 镜像id 用户名(账号名)/仓库名:版本号docker tag diytomcat xxx/diytomcat:version1.0docker push 用户名(账号名)/仓库名:版本号docker push xxx/diytomcat:version1.0# 发布到阿里云镜像库中登录阿里云，找到容器镜像服务，创建个人实例后，找到命名空间，创建一个命名空间；创建容器镜像，仓库信息选择本地仓库退出登录刚刚登录的账号：docker logout按照阿里云镜像下面的步骤来登录push即可\n\n\n\n\n\n7 redis集群部署特点：分片、高可用、负载均衡\n当r-m3 挂了，备份 r-s3 会进行替代\n\n准备：移除所有容器，防止卡顿\n1docker rm -f $(docker ps -aq)\n\n自定义一个网络\n1docker network create redis --subnet 172.38.0.0/16\n\n通过脚本来创建六个redis配置\n12345678910111213141516for port in $(seq 1 6); \\do \\mkdir -p /mydata/redis/node-$&#123;port&#125;/conftouch /mydata/redis/node-$&#123;port&#125;/conf/redis.confcat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.confport 6379 bind 0.0.0.0cluster-enabled yes cluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1$&#123;port&#125;cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdone\n\n\n\n1cd /mydata/\n\n\n\n启动容器\n1234docker run -p 6371:6379 -p 16371:16379 --name redis-1 \\    -v /mydata/redis/node-1/data:/data \\    -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\    -d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf","dateCreated":"2023-03-07T22:10:20+08:00","dateModified":"2023-03-07T09:37:19+08:00","datePublished":"2023-03-07T22:10:20+08:00","description":"简介：简单易懂的Docker入门文章，因为是学习中/后的总结性文章，为了保持一贯的队形，这篇笔记仍然起名为学习笔记（其实就是懒得想了，哪怕为此写了这么长的一段废话，嘻嘻🤭，略略略）\n同步更新地址：","headline":"Docker学习笔记","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"Abilish","sameAs":["https://github.com/abilish","http://stackoverflow.com/users"],"image":"avatar.png","logo":{"@type":"ImageObject","url":"avatar.png"}},"url":"http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","keywords":"创作中, Docker"}</script>
    <meta name="description" content="简介：简单易懂的Docker入门文章，因为是学习中&#x2F;后的总结性文章，为了保持一贯的队形，这篇笔记仍然起名为学习笔记（其实就是懒得想了，哪怕为此写了这么长的一段废话，嘻嘻🤭，略略略） 同步更新地址：">
<meta property="og:type" content="blog">
<meta property="og:title" content="Docker学习笔记">
<meta property="og:url" content="http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Do">
<meta property="og:description" content="简介：简单易懂的Docker入门文章，因为是学习中&#x2F;后的总结性文章，为了保持一贯的队形，这篇笔记仍然起名为学习笔记（其实就是懒得想了，哪怕为此写了这么长的一段废话，嘻嘻🤭，略略略） 同步更新地址：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/02/17/QvknuBAE2l91iqb.png">
<meta property="og:image" content="http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1676711860958.png">
<meta property="og:image" content="http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1676712052236.png">
<meta property="og:image" content="https://ts1.cn.mm.bing.net/th/id/R-C.d955a02688023db6aca5ba2d4e03f9ae?rik=NbFbefhG8zRz/g&riu=http://itwangqing.net.cn/mweb/15808978958059.jpg&ehk=OETmGXExvQXv+Gu6xBh7gh4Xix2O7S3z1PD/NBJobO4=&risl=&pid=ImgRaw&r=0">
<meta property="og:image" content="http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1676711593560.png">
<meta property="og:image" content="http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1676816820100.png">
<meta property="og:image" content="http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1677513000633.png">
<meta property="og:image" content="http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1678017716675.png">
<meta property="og:image" content="http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1674740418153.png">
<meta property="og:image" content="http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1674740633100.png">
<meta property="og:image" content="http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1678065538739.png">
<meta property="article:published_time" content="2023-03-07T14:10:20.000Z">
<meta property="article:modified_time" content="2023-03-07T01:37:19.082Z">
<meta property="article:author" content="Abilish">
<meta property="article:tag" content="创作中">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/02/17/QvknuBAE2l91iqb.png">
    
    
        
    
    
        <meta property="og:image" content="http://example.com/assets/images/avatar.png"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-dnipa5uemzhoi9vvrnmqb2ijfofk2ioy6agrjzdgxdcme4ri2nzo71ht0dut.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Do
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.png" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.png" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">Abilish</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Less is More.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="归档"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/abilish"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="http://stackoverflow.com/users"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Docker学习笔记
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2023-03-07T22:10:20+08:00">
	
		    3月 07, 2023
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>, <a class="category-link" href="/categories/%E5%AD%A6%E4%B9%A0/Docker/">Docker</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <!-- excerpt -->

<h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Docker-%E7%AE%80%E4%BB%8B"><span class="toc-text">一、Docker 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Docker-%E6%A6%82%E8%BF%B0%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">二、Docker 概述和常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Docker-%E6%95%B4%E4%BD%93%E7%90%86%E8%A7%A3"><span class="toc-text">1. Docker 整体理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BE%85%E5%8A%A9%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99"><span class="toc-text">2. 辅助命令及学习网站</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-text">3. 镜像命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">4. 容器命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB"><span class="toc-text">5 常用命令汇总</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Docker-%E9%95%9C%E5%83%8F%E7%90%86%E8%A7%A3"><span class="toc-text">6 Docker 镜像理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-commit%E9%95%9C%E5%83%8F"><span class="toc-text">7 commit镜像</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Docker-%E8%BF%9B%E9%98%B6"><span class="toc-text">三、Docker 进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86docker"><span class="toc-text">0 可视化管理docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">1. 容器数据卷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-DockerFile-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-text">2. DockerFile 构建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-text">数据卷容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DockerFile"><span class="toc-text">DockerFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DockerFile-%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%8C%87%E4%BB%A4"><span class="toc-text">DockerFile 构建过程及指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CMD-%E5%92%8C-ENTRYPOINT-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">CMD 和 ENTRYPOINT 的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Docker-%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86"><span class="toc-text">3.Docker 网络原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker0"><span class="toc-text">Docker0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94"><span class="toc-text">容器互联</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93link-%EF%BC%88%E5%85%A5%E9%97%A8%E4%BA%92%E8%81%94-%E9%80%9A%E8%BF%87%E5%90%8D%E5%AD%97ping%E9%80%9A%E4%B8%A4%E4%B8%AA%E5%AE%B9%E5%99%A8%EF%BC%89"><span class="toc-text">–link （入门互联 通过名字ping通两个容器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C-%E9%AB%98%E7%BA%A7%E4%BA%92%E8%81%94"><span class="toc-text">自定义网络(高级互联)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">网络模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%BD%91%E7%BB%9C"><span class="toc-text">默认网络</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-text">自定义网络</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E9%80%9A"><span class="toc-text">网络连通</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-IDEA-%E6%95%B4%E5%90%88-Docker"><span class="toc-text">4.IDEA 整合 Docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Docker-Compose-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86"><span class="toc-text">5.Docker Compose  集群管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Docker-Swarm-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92"><span class="toc-text">6. Docker Swarm 容器编排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-CI-CD-jenkins"><span class="toc-text">7.CI&#x2F;CD jenkins</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Docker"><span class="toc-text">四、深入理解Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E6%A1%A3"><span class="toc-text">读文档</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0"><span class="toc-text">五、项目练习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Docker-%E9%83%A8%E7%BD%B2Nginx"><span class="toc-text">1 Docker 部署Nginx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8docker%E6%9D%A5%E8%A3%85%E4%B8%80%E4%B8%AAtomcat"><span class="toc-text">2 使用docker来装一个tomcat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%83%A8%E7%BD%B2-es-kibana"><span class="toc-text">3 部署 es + kibana</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%89%E8%A3%85%E5%B9%B6%E6%8C%82%E8%BD%BDmysql"><span class="toc-text">4 安装并挂载mysql</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-DockerFile-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-text">5 DockerFile 构建镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-tomcat-%E9%95%9C%E5%83%8F"><span class="toc-text">6 tomcat 镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-redis%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2"><span class="toc-text">7 redis集群部署</span></a></li></ol></li></ol>



<h1 id="一、Docker-简介"><a href="#一、Docker-简介" class="headerlink" title="一、Docker 简介"></a>一、Docker 简介</h1><p>根据百度百科的介绍：</p>
<blockquote>
<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Linux">Linux</a>或Windows操作系统的机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。</p>
</blockquote>
<p><strong>Docker采用的是Go语言编写的</strong>，该语言一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言，常用于Web程序开发，并且具有成熟的Web开发框架，如Beego、Gin、Iris等等。</p>
<p><strong>Go语言描述</strong></p>
<p>Go的语法接近C语言，但对于变量的声明有所不同。Go支持垃圾回收功能。</p>
<h1 id="二、Docker-概述和常用命令"><a href="#二、Docker-概述和常用命令" class="headerlink" title="二、Docker 概述和常用命令"></a>二、Docker 概述和常用命令</h1><h2 id="1-Docker-整体理解"><a href="#1-Docker-整体理解" class="headerlink" title="1. Docker 整体理解"></a>1. Docker 整体理解</h2><p><img src="https://s2.loli.net/2023/02/17/QvknuBAE2l91iqb.png" alt="576507-docker1.png"></p>
<p><strong>docker解决问题</strong>：项目带上环境安装打包，可以跨平台（windows–&gt;Linux）</p>
<p><strong>Docker和VM对比</strong>：</p>
<p>Vmware，虚拟电脑，很<strong>笨重</strong>，属于虚拟化技术</p>
<p>​    dockers容器技术也是一种虚拟化技术</p>
<p>docker：隔离，镜像（最核心的环境）十分<strong>小巧</strong></p>
<ul>
<li>传统虚拟机，<strong>虚拟出一套硬件</strong>，运行一个完整的操作系统，然后在这个操作系统上安装和运行软件</li>
<li>容器内的应用直接运行在宿主机的内核上，容器没有自己的内核，也<strong>没有虚拟硬件</strong>，因此更为轻便。每个容器之间是互相隔离的，每个容器内都有一个属于自己的文件系统，且互不影响</li>
</ul>
<p>Docker有着比虚拟机更少的抽象层。</p>
<p><img src="Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1676711860958.png" alt="1676711860958"></p>
<p>Docker利用的是宿主机的内核，VM用的是Guest OS，因此，新建容器时，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。VM是分钟级的，docker是秒级的</p>
<p><img src="Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1676712052236.png" alt="1676712052236"></p>
<p>学习路径：先学会传统虚拟机上如何部署环境，再学习Docker</p>
<p><strong>概述</strong>：基于Go语言开发，开源</p>
<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.d955a02688023db6aca5ba2d4e03f9ae?rik=NbFbefhG8zRz/g&riu=http://itwangqing.net.cn/mweb/15808978958059.jpg&ehk=OETmGXExvQXv+Gu6xBh7gh4Xix2O7S3z1PD/NBJobO4=&risl=&pid=ImgRaw&r=0" alt="docker基本组成"></p>
<p>镜像(Image)：镜像是一个原始模板，通过模板来创建容器</p>
<p>容器(container)：容器是来提供服务的。启动，停止，删除等等</p>
<p>仓库(repository)：仓库是用来存放镜像的地方，类似与github、gitee等等，分为共有私有。docker hub 在国外，需要配置国内的镜像加速。</p>
<p>**安装基本步骤(cnetos8)**：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">1. 卸载旧版本</span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line">2. 安装相关依赖</span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">3. 设置国内yum镜像源</span><br><span class="line">国外源：sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">阿里云国内源安装docker：sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. 更新yum软件包索引</span><br><span class="line">centos8 无fast参数：yum makecache</span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line">5. 安装docker</span><br><span class="line">最新版的安装方式(2023/2/18)：docker-ce社区版；docker-ee企业版</span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"></span><br><span class="line">一路按 y</span><br><span class="line"></span><br><span class="line">6. 启动docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">7. 验证安装成功</span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line">8. 通过启动镜像验证安装成功</span><br><span class="line">sudo docker run hello-world</span><br><span class="line"></span><br><span class="line">9. 查看镜像是否已经被下载</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line">10. 卸载docker</span><br><span class="line">a. 卸载依赖</span><br><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras</span><br><span class="line">b. 删除资源</span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br><span class="line"></span><br><span class="line">11. 设置阿里云docker镜像加速</span><br><span class="line">登录阿里云官方，找到“容器镜像服务”--&gt; 镜像工具 --&gt; 镜像加速器</span><br><span class="line">选择所使用的操作系统，按照步骤来配置，下面的命令依次敲：</span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://自己的仓库地址，你猜.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上通过Socket从客户端访问。DockerServer接收到Docker-Client的指令就会执行。容器内的端口映射到宿主机的端口。</p>
<p><img src="Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1676711593560.png" alt="1676711593560"></p>
<h2 id="2-辅助命令及学习网站"><a href="#2-辅助命令及学习网站" class="headerlink" title="2. 辅助命令及学习网站"></a>2. 辅助命令及学习网站</h2><p>docker官网</p>
<p>docker hub  仓库地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查看操作系统的发行版号</span></span><br><span class="line">uname -r  </span><br><span class="line"><span class="meta"># </span><span class="language-bash">显示系统名、节点名称、操作系统的发行版号、内核版本等等</span></span><br><span class="line">uname -a </span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看虚拟机系统版本信息</span></span><br><span class="line">cat /etc/os-release</span><br></pre></td></tr></table></figure>

<p>帮助命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">显示docker的版本信息</span></span><br><span class="line">docker version</span><br><span class="line"><span class="meta"># </span><span class="language-bash">显示docker系统信息，包括镜像和容器的数量</span></span><br><span class="line">docker info</span><br><span class="line"><span class="meta"># </span><span class="language-bash">帮助万能命令</span></span><br><span class="line">docker 命令 --help  </span><br></pre></td></tr></table></figure>

<p>docker命令帮助文档地址：<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p>
<p>菜鸟教程中文地址：<a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全 | 菜鸟教程 (runoob.com)</a></p>
<h2 id="3-镜像命令"><a href="#3-镜像命令" class="headerlink" title="3. 镜像命令"></a>3. 镜像命令</h2><p><strong>docker images 查看镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line"><span class="meta"># </span><span class="language-bash">常用参数</span></span><br><span class="line">-a, --all             Show all images (default hides intermediate images)</span><br><span class="line">-q, --quiet           Only show image IDs</span><br></pre></td></tr></table></figure>

<p>a. 通过官方文档来学习命令：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/images/">https://docs.docker.com/engine/reference/commandline/images/</a></p>
<p>b. 通过help来学习<code>docker images --help</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">相当于在docker hub上搜索</span></span><br><span class="line">docker search mysql </span><br><span class="line"><span class="meta"># </span><span class="language-bash">过滤出收藏量大于3000的，且展示详细信息</span></span><br><span class="line">docker search mysql --filter=STARS=3000 --no-trunc</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">列出images完整<span class="built_in">id</span></span></span><br><span class="line">docker images --no-trunc</span><br></pre></td></tr></table></figure>



<p><strong>docker pull 下载镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名:tag</span><br></pre></td></tr></table></figure>

<p>不写tag默认下载最新版本，docker images 分层下载，是image的核心，联合文件系统。</p>
<p>pull中的design是签名，最后一行为真实地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">pull mysql等价于从真实地址去拉取</span></span><br><span class="line">docker pull mysql</span><br><span class="line">docker pull docker.io/library/mysql:latest</span><br></pre></td></tr></table></figure>



<p><strong>docker rmi 删除镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f 镜像id</span><br><span class="line">docker rmi repository:tag</span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除所有镜像</span></span><br><span class="line">docker rmi -f $(docker images -aq)</span><br></pre></td></tr></table></figure>





<h2 id="4-容器命令"><a href="#4-容器命令" class="headerlink" title="4. 容器命令"></a>4. 容器命令</h2><p>前提，先pull一个镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>



<p><strong>docker run 启动容器</strong></p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/run/">docker run | Docker Documentation</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"><span class="meta"># </span><span class="language-bash">如果没有下载启动时会自动下载，默认下载最新版本</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">常用参数</span></span><br><span class="line">--name 给容器命名</span><br><span class="line">-d     后台方式启动(后台运行时如果没有前台进程，docker发现没有应用就会自动停止)</span><br><span class="line">-i     交互式操作</span><br><span class="line">-t     终端</span><br><span class="line">-p     指定容器的端口，将容器端口映射到主机  -p 8080：8080</span><br><span class="line">	-p 主机端口:容器端口   （最常用的一种方式）</span><br><span class="line">	-p 容器端口</span><br><span class="line">	容器端口</span><br><span class="line">	ip ip:主机端口:容器端口</span><br><span class="line">-P     大写的P是随机指定端口</span><br></pre></td></tr></table></figure>

<p>启动一个容器: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it centos /bin/bash</span><br></pre></td></tr></table></figure>

<p>非后台启动，<strong>退出</strong>命令为：exit</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">列出正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta"># </span><span class="language-bash">常用参数</span></span><br><span class="line">-a    列出所有，包括历史曾运行过的容器</span><br><span class="line">-n=1  只显示最近的一个</span><br><span class="line">-q    只显示容器的编号</span><br></pre></td></tr></table></figure>

<p><strong>退出容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">直接停止并退出</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta"># </span><span class="language-bash">容器不停止退出</span></span><br><span class="line">Ctrl + P + Q</span><br></pre></td></tr></table></figure>

<p><strong>删除容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">删除指定容器</span></span><br><span class="line">docker rm 容器id</span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除所有的容器</span></span><br><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line"><span class="meta"># </span><span class="language-bash">通过管道符过滤删除</span></span><br><span class="line">docker ps -a -q|xargs docker rm</span><br></pre></td></tr></table></figure>

<p><strong>启动容器</strong></p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">启动容器</span></span><br><span class="line">docker start 容器id</span><br><span class="line"><span class="meta"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart 容器id</span><br><span class="line"><span class="meta"># </span><span class="language-bash">停止当前正在运行的容器</span></span><br><span class="line">docker stop 容器id</span><br><span class="line"><span class="meta"># </span><span class="language-bash">强制停止当前容器</span></span><br><span class="line">docker kill 容器id</span><br></pre></td></tr></table></figure>



<h2 id="5-常用命令汇总"><a href="#5-常用命令汇总" class="headerlink" title="5 常用命令汇总"></a>5 常用命令汇总</h2><p><strong>查看日志</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs | Docker Documentation</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器id</span><br><span class="line"><span class="meta"># </span><span class="language-bash">常用参数</span></span><br><span class="line">-f : 跟踪日志输出，持续输出日志内容</span><br><span class="line">-t : 显示时间戳</span><br><span class="line">--tail/-n :仅列出最新N条容器日志  -n 15</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">shell 脚本</span></span><br><span class="line">&quot;while true;do echo docker;sleep 1;done&quot;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">重新启动一个容器，运行shell脚本，使其不断打印，产生日志</span></span><br><span class="line">docker run -d centos /bin/sh -c &quot;while true;do echo docker;sleep 1;done&quot;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看容器日志</span></span><br><span class="line">docker logs -t -f -n 10 71f8b56ac14e</span><br></pre></td></tr></table></figure>



<p><strong>查看容器中的进程信息</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器id</span><br><span class="line"><span class="meta"># </span><span class="language-bash">显示</span></span><br><span class="line">UID  用户ID</span><br><span class="line">PID  父ID</span><br><span class="line">PPID 进程ID</span><br></pre></td></tr></table></figure>



<p><strong>查看镜像的元数据</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>



<p><strong>进入当前正在运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">进入容器后开启新终端（常用）</span></span><br><span class="line">docker exec -it 容器id/name bashShell</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">例：</span></span><br><span class="line">docker exec -it 71f8b56ac14e /bin/bash</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">进入容器正在执行的终端，不会启动新的进程</span></span><br><span class="line">docker attach 容器id</span><br><span class="line"><span class="meta"># </span><span class="language-bash">Attach <span class="built_in">local</span> standard input, output, and error streams to a running container</span></span><br></pre></td></tr></table></figure>



<p><strong>从容器内拷贝文件到主机</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:容器内路径 目的的主机路径</span><br><span class="line"></span><br><span class="line">docker cp 9d140e95797a:/home/a.txt /home</span><br></pre></td></tr></table></figure>



<p>官方图：</p>
<p><img src="Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1676816820100.png" alt="1676816820100"></p>
<h2 id="6-Docker-镜像理解"><a href="#6-Docker-镜像理解" class="headerlink" title="6 Docker 镜像理解"></a>6 Docker 镜像理解</h2><p>镜像是独立的软件包</p>
<p>Docker镜像加载原理为**UnionFS (联合文件系统)**，镜像可以通过分层来进行继承，基于基础镜像，制作复制具体的应用镜像。</p>
<p>docker的镜像实际上有一层一层的文件系统组成，这种层级的文件系统就是UnionFS。</p>
<p><strong>bootfs</strong>(boot file system) linux刚启动时会加载bootfs文件系统，Dcker也是一样的，加载完成后整个内核就在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs</p>
<p><strong>rootfs</strong>(root file system) ，在bootfs之上。包含的就是典型Linux系统中的 /dev, /proc, /bin, /etc 等标准目录和文件，rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等</p>
<p><strong>为什么Docker中的centos很小？</strong></p>
<p>因为rootfs中只包含了最基本的命令、工具和程序库，直接用的是主机的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。</p>
<p><strong>分层</strong></p>
<p>分层进行复用。</p>
<p>Docker的镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层就是我们说的容器层，容器之下只读，无法改变的部分都叫做镜像层。</p>
<h2 id="7-commit镜像"><a href="#7-commit镜像" class="headerlink" title="7 commit镜像"></a>7 commit镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器成为一个新的副本</span><br><span class="line"></span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">项目练习2 拷贝tomcat基本镜像</span><br><span class="line"></span><br><span class="line">docker commit -a=&quot;Abilish&quot; -m=&quot;add webapps app&quot; 236dffd55cf1 tomcat02:1.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看自己提交的镜像</span></span><br><span class="line">docker images </span><br></pre></td></tr></table></figure>







<h1 id="三、Docker-进阶"><a href="#三、Docker-进阶" class="headerlink" title="三、Docker 进阶"></a>三、Docker 进阶</h1><h2 id="0-可视化管理docker"><a href="#0-可视化管理docker" class="headerlink" title="0 可视化管理docker"></a>0 可视化管理docker</h2><p>portainer</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure>

<p>设置登录密码，选择本地(local)</p>
<p>Rancher(CI/CD)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure>





<p><strong>挂载分为使用命令挂载，以及用DockerFile挂载两种方式。</strong></p>
<h2 id="1-容器数据卷"><a href="#1-容器数据卷" class="headerlink" title="1. 容器数据卷"></a>1. 容器数据卷</h2><p>产生原因：数据和容器分离，数据单独独立，持久化保存。</p>
<p>MySQL数据可以存储在本地。容器之间可以有一个数据共享的技术。Docker 容器中产生的数据剋同步到本地，因此产生了<strong>目录挂载</strong>。<strong>目录挂载就是容器内和容器外连接的目录是同步更新的。</strong></p>
<p><strong>方式一</strong>：使用命令挂载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器目录</span><br><span class="line"></span><br><span class="line">docker run -it -v /home/test:/home centos /bin/bash</span><br><span class="line"><span class="meta"># </span><span class="language-bash">可以查看到容器的挂载信息</span></span><br><span class="line">docker inspect 容器id</span><br><span class="line">......</span><br><span class="line">        &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/home/test&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/home&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">            &#125;</span><br><span class="line">......</span><br><span class="line"><span class="meta"># </span><span class="language-bash">容器删除，本机上挂载的数据依旧存在</span></span><br></pre></td></tr></table></figure>



<p><strong>具名挂载和匿名挂载</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">匿名挂载：只写容器内名字不写容器外名字</span></span><br><span class="line">-v 容器内路径</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看本地所有的卷的情况，显示的是没有名字的这就是匿名挂载</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">具名挂载</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta"># </span><span class="language-bash">可以看到挂载的名字为 juming-nginx</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看这个卷的位置</span></span><br><span class="line">docker volume inspect juming-nginx</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2023-02-22T22:48:38+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;,  # 此参数为挂载的目录位置</span><br><span class="line">        &quot;Name&quot;: &quot;juming-nginx&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta"># </span><span class="language-bash">在没有指定目录的情况下，基本所有的卷都在这个位置 /var/lib/docker/volumes/卷名/_data</span></span><br></pre></td></tr></table></figure>

<p>docker volume –help</p>
<p><strong>总结：挂载的方式总共分为三种，指定路径挂载、匿名挂载、具名挂载</strong></p>
<p>其他：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">挂载目录后面加上 ro 或者 rw</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">ro 表示 <span class="built_in">read</span> only 只读</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">rw 表示 <span class="built_in">read</span> write 可读可写</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">默认为 rw</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">设置的容器权限。如果是 ro ，那么在容器内部是只读的，无法改变，只能通过宿主机改变</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx</span><br></pre></td></tr></table></figure>





<h2 id="2-DockerFile-构建镜像"><a href="#2-DockerFile-构建镜像" class="headerlink" title="2. DockerFile 构建镜像"></a>2. DockerFile 构建镜像</h2><p><strong>挂载方式二</strong>：</p>
<p>Dockerfile 就是用来构建 docker 镜像的构建文件，是命令脚本，通过这个脚本可以生成镜像，镜像是一层一层的，脚本是一个一个命令，每个命令都是一层。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">1 新建一个dockerfile01文件，编辑，写入如下的命令：</span></span><br><span class="line"></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><br><span class="line"></span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">文件中的内容，或者指令都是大写的</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">2 docker build 命令构建镜像</span></span><br><span class="line">docker build -f dockerfile01 -t abilish/centos:1.0 .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">常用参数</span></span><br><span class="line">-f   file文件名</span><br><span class="line">-t   生成的镜像及标签名 Name and optionally a tag in the name:tag format</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">3 执行后可以看到成功生成的镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">4 启动镜像</span></span><br><span class="line">docker run -it afa669b6bce7 /bin/bash</span><br><span class="line">ls</span><br><span class="line"><span class="meta"># </span><span class="language-bash">可以看到其中的两个目录：volume01、volume02，这两个目录就是刚刚挂载的目录</span></span><br><span class="line">docker inspect 容器id</span><br><span class="line"><span class="meta"># </span><span class="language-bash">可以查到主机中挂载的位置</span></span><br></pre></td></tr></table></figure>

<p>如果在构建镜像时没有设置挂载，那么需要在启动镜像时设置 -v 挂载参数</p>
<h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>多个容器之间实现数据同步</p>
<p>被挂载的叫做父容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--volumes-from </span><br><span class="line"></span><br><span class="line">docker run -it --name docker01 abilish/centos:1.0</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动第二个镜像并进行挂载</span></span><br><span class="line">docker run -it --name docker02 --volumes-from docker01  abilish/centos:1.0</span><br><span class="line"><span class="meta"># </span><span class="language-bash">volume01、volume02 镜像之间会同步更新</span></span><br><span class="line">docker run -it --name docker03 --volumes-from docker01  abilish/centos:1.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">停止父容器，在其他容器中（docker02、docker03）挂载目录依旧同步，</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">其他的容器中之前创建的文件不会消失</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除父容器，docker02、docker03 之间挂载目录的数据依旧时同步的</span></span><br><span class="line">docker rm -f docker01</span><br></pre></td></tr></table></figure>



<p>问题(待解决)：如果两个容器有不同数量的挂载目录呢？如果挂载之前每个容器中有不同的数据，能合并吗？</p>
<p>同理，mysql中也就可以实现数据同步了</p>
<p>容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止</p>
<p>但是一但持久化到了本地，就可以持久化保存了</p>
<h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><p><strong>概念</strong>：dockerfile 是用来构建docker镜像的文件，命令参数脚本</p>
<p>构建步骤：</p>
<p>1、编写一个 dockerfile 文件</p>
<p>2、docker build 构建成为一个镜像</p>
<p>3、docker run 运行镜像</p>
<p>4、docker push 发布镜像（DockerHub或者阿里云镜像库）</p>
<p>centos为例：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/CentOS/sig-cloud-instance-images/blob/b2d195220e1c5b181427c3172829c23ab9cd27eb/docker/Dockerfile">sig-cloud-instance-images/Dockerfile at b2d195220e1c5b181427c3172829c23ab9cd27eb · CentOS/sig-cloud-instance-images (github.com)</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD centos-7-x86_64-docker.tar.xz /</span><br><span class="line"></span><br><span class="line">LABEL \</span><br><span class="line">    org.label-schema.schema-version=&quot;1.0&quot; \</span><br><span class="line">    org.label-schema.name=&quot;CentOS Base Image&quot; \</span><br><span class="line">    org.label-schema.vendor=&quot;CentOS&quot; \</span><br><span class="line">    org.label-schema.license=&quot;GPLv2&quot; \</span><br><span class="line">    org.label-schema.build-date=&quot;20201113&quot; \</span><br><span class="line">    org.opencontainers.image.title=&quot;CentOS Base Image&quot; \</span><br><span class="line">    org.opencontainers.image.vendor=&quot;CentOS&quot; \</span><br><span class="line">    org.opencontainers.image.licenses=&quot;GPL-2.0-only&quot; \</span><br><span class="line">    org.opencontainers.image.created=&quot;2020-11-13 00:00:00+00:00&quot;</span><br><span class="line"></span><br><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure>

<p>大多数官方的镜像都是基础包，用户需要自定义搭建镜像</p>
<h3 id="DockerFile-构建过程及指令"><a href="#DockerFile-构建过程及指令" class="headerlink" title="DockerFile 构建过程及指令"></a>DockerFile 构建过程及指令</h3><p>基础知识：</p>
<p>1、每个保留关键字(指令)都必须是大写字母</p>
<p>2、执行从上到下顺序执行</p>
<p>3、# 表示注释</p>
<p>4、每一个指令都会创建提交一个新的镜像层</p>
<p>DockerFile 是面向开发的，用来发布项目，做镜像</p>
<p><strong>指令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM        # 基础镜像</span><br><span class="line">MAINTAINER  # 镜像是谁写的，维护者信息，姓名+邮箱</span><br><span class="line">RUN         # 镜像构建的时候需要运行的命令</span><br><span class="line">ADD         # 步骤，tomcat镜像，上传压缩包，会自动解压</span><br><span class="line">WORKDIR     # 镜像的工作目录</span><br><span class="line">VOLUME      # 挂载的目录</span><br><span class="line">EXPOSE      # 指定端口，这里写了就不用指定 -p 了</span><br><span class="line">CMD         # 指定这个容器启动的时候要运行的命令，是替换命令行中的命令</span><br><span class="line">ENTRYPOINT  # 指定这个容器启动的时候要运行的命令，是在命令行命令后追加命令</span><br><span class="line">ONBUILD     # 当构建一个被继承 DockerFile 这个时候就会运行 ONBUILD 的指令，触发指令。</span><br><span class="line">COPY        # 类似 ADD ，将我们文件拷贝到镜像中</span><br><span class="line">ENV         # 构建的时候设置环境变量</span><br></pre></td></tr></table></figure>





<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查看构建历史</span></span><br><span class="line">docker history 镜像id</span><br></pre></td></tr></table></figure>



<h4 id="CMD-和-ENTRYPOINT-的区别"><a href="#CMD-和-ENTRYPOINT-的区别" class="headerlink" title="CMD 和 ENTRYPOINT 的区别"></a>CMD 和 ENTRYPOINT 的区别</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CMD         # 指定这个容器启动的时候要运行的命令，是替换命令行中的命令</span><br><span class="line">ENTRYPOINT  # 指定这个容器启动的时候要运行的命令，是在命令行命令后追加命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim dockerfile-cmd-test</span><br><span class="line"></span><br><span class="line">FROM centos</span><br><span class="line">CMD [&quot;ls&quot;, &quot;-a&quot;]</span><br><span class="line"></span><br><span class="line">docker build -f dockerfile-cmd-test -t cmdtest .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">run 这个容器后会输出当前目录，这是因为DockerFile中增加了CMD命令</span></span><br><span class="line">docker run cmdtest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">如果在run时增加-l参数，-l会替换 CMD [<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>] 命令，-l不是命令所以会报错</span></span><br><span class="line">docker run cmdtest -l</span><br><span class="line"><span class="meta"># </span><span class="language-bash">正确的方式为：</span></span><br><span class="line">docker run cmdtest ls -al</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim dockerfile-cmd-entrypoint</span><br><span class="line"></span><br><span class="line">FROM centos</span><br><span class="line">ENTRYPOINT [&quot;ls&quot;, &quot;-a&quot;]</span><br><span class="line"></span><br><span class="line">docker build -f dockerfile-cmd-entrypoint -t entorypoint-test .</span><br><span class="line"><span class="meta"># </span><span class="language-bash">可以执行成功，并且输出 <span class="built_in">ls</span> -al 的结果</span></span><br><span class="line">docker run b40785390900 -l</span><br></pre></td></tr></table></figure>







<p><strong>DockerFile</strong> ：构建文件，定义了一切的步骤，源代码</p>
<p><strong>DockerImages</strong> ：通过 DockerFile 构建生成的镜像，最终发布和运行的产品</p>
<p><strong>Docker容器</strong> ：容器是镜像运行起来提供服务的</p>
<h2 id="3-Docker-网络原理"><a href="#3-Docker-网络原理" class="headerlink" title="3.Docker 网络原理"></a>3.Docker 网络原理</h2><h3 id="Docker0"><a href="#Docker0" class="headerlink" title="Docker0"></a>Docker0</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查看网卡</span></span><br><span class="line">ip addr</span><br><span class="line">结果：</span><br><span class="line">lo 本机回环地址</span><br><span class="line">eth0 内网地址</span><br><span class="line">docker0 docker网卡地址，桥接模式，使用的技术是 veth-pair 技术</span><br></pre></td></tr></table></figure>

<p>Docker 中的网络访问</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it tomcat_net ip addr</span><br><span class="line"></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">76: eth0@if77: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="meta"># </span><span class="language-bash">可以看到容器启动的时候会得到一个 eth0@  的ip地址，这是dockers分配的ip地址。</span></span><br><span class="line">ping 172.17.0.2</span><br><span class="line"><span class="meta"># </span><span class="language-bash">Linux是可以ping通docker容器内部的</span></span><br><span class="line">容器带来的网卡都是成对出现的，veth-pair 技术，是一对的虚拟设备接口，一端连着协议，一端彼此相连。veth-pair 充当一个桥梁，连接各种虚拟网络设备的。</span><br><span class="line"><span class="meta"># </span><span class="language-bash">不同容器之前是可以互相ping通的</span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">docker0 相当于是路由器，转发消息，不同容器共用一个路由器</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">所有的容器不指定网络的情况下，都是 docker0 路由的，docker会给我们的容器分配一个默认的可用 IP</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">只要容器删除，对应的网桥就没了</span></span><br><span class="line"></span><br><span class="line">255.255.0.1/16</span><br><span class="line"></span><br><span class="line">正常的地址：00000000.00000000.00000000.00000000</span><br><span class="line">十进制：255.255.255.255</span><br><span class="line">一个路由下：255.255.0.0  255*255-0.0.0.0(回环地址)-255.255.255.255(最终地址)=65535</span><br><span class="line"></span><br><span class="line">255.255.0.1/24  域 局域网，一般小教室是24，公司是16</span><br></pre></td></tr></table></figure>



<p><img src="Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1677513000633.png" alt="1677513000633"></p>
<h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><h4 id="–link-（入门互联-通过名字ping通两个容器）"><a href="#–link-（入门互联-通过名字ping通两个容器）" class="headerlink" title="–link （入门互联 通过名字ping通两个容器）"></a>–link （入门互联 通过名字ping通两个容器）</h4><p>启动两个tomcat：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --name tomcat01 tomcat</span><br><span class="line">docker run -d -P --name tomcat02 tomcat</span><br></pre></td></tr></table></figure>

<p>直接通过名字ping是无法ping通的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it tomcat02 ping tomcat01</span><br><span class="line">OCI runtime exec failed: exec failed: unable to start container process: exec: &quot;ping&quot;: executable file not found in $PATH: unknown</span><br></pre></td></tr></table></figure>

<p>创建容器时通过 –link 参数来 link 另一个容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --name tomcat03 --link tomcat02 tomcat</span><br></pre></td></tr></table></figure>

<p>通过 <code>--link</code> 参数建立连接后，只能从03的方向ping 02，<strong>反过来是ping不通的</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it tomcat03 ping tomcat02</span><br></pre></td></tr></table></figure>

<p>如果在容器启动时进行了link，但被link的容器删除掉，即使再创建一个同名的容器也是无法ping通的</p>
<p>docker network 命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker network -help</span><br><span class="line">docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">d50b0dcbbc57   bridge    bridge    local</span><br><span class="line">eeea9a40175b   host      host      local</span><br><span class="line">8460731336c8   none      null      local</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看网络信息</span></span><br><span class="line">docker network inspect d50b0dcbbc57</span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用下面的命令可以找到 <span class="string">&quot;Links&quot;</span> 参数，存放了<span class="built_in">link</span>的信息</span></span><br><span class="line">docker inspect 容器id</span><br><span class="line"><span class="meta"># </span><span class="language-bash">或者通过第二种方式查看，在hosts文件中增加了一个映射</span></span><br><span class="line">docker exec -it tomcat03 cat /etc/hosts</span><br><span class="line">...</span><br><span class="line">172.17.0.5	tomcat02 606ae16ac1bd</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h4 id="自定义网络-高级互联"><a href="#自定义网络-高级互联" class="headerlink" title="自定义网络(高级互联)"></a>自定义网络(高级互联)</h4><p>查看所有的网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>



<h5 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a><strong>网络模式</strong></h5><p><img src="Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1678017716675.png" alt="1678017716675"></p>
<p>**bridge(桥接模式)**：搭桥，通过 0.1 可以访问 0.2 和 0.3 ，0.1起到转发的作用。docker默认使用桥接模式，自己创建的网络也使用桥接模式</p>
<p><strong>none(不配置网络)</strong></p>
<p>**host(主机模式)**：和宿主机共享网络</p>
<p>container(容器内网络连通)：用的较少，局限很大</p>
<h5 id="默认网络"><a href="#默认网络" class="headerlink" title="默认网络"></a>默认网络</h5><p>直接启动时时可以指定参数，bridge 就是docker0的网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --name tomcat01 --net bridge diytomcat</span><br></pre></td></tr></table></figure>

<p>docker0的特点：</p>
<ol>
<li>–net 默认走docker0</li>
<li>域名不能访问，–link可以打通连接</li>
</ol>
<h5 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line"><span class="meta"># </span><span class="language-bash">常用参数</span></span><br><span class="line">--driver: 指定网络模式，bridge 桥接模式</span><br><span class="line">--subnet：子网，192.168.0.0/16，16时65535个子网，如果为24，那么只能创建255个</span><br><span class="line">--gateway：指定网关，从哪里出去</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">ls</span>查看一下，即可看到创建的网络 mynet</span></span><br><span class="line">docker network ls</span><br><span class="line">2e4276da5434   mynet     bridge    local</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动一个使用自定义网络的容器</span></span><br><span class="line">docker run -d -P --name tomcat-net-01 --net mynet diytomcat</span><br><span class="line">docker run -d -P --name tomcat-net-02 --net mynet diytomcat</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看网络状态</span></span><br><span class="line">docker network inspect mynet</span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用自定义的网络是可以 ping 通的</span> </span><br><span class="line">docker exec -it tomcat-net-01 ping tomcat-net-02</span><br><span class="line">docker exec -it tomcat-net-02 ping tomcat-net-01</span><br></pre></td></tr></table></figure>

<p>自定义的网络docker0已经维护好了对应的关系，功能更加完善，无需指定–link参数。</p>
<p>不同的集群使用不同的网络，保证集群是安全和健康的</p>
<h4 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h4><p>在<code>docker0</code>网络中启动两个容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --name tomcat1 diytomcat</span><br><span class="line">docker run -d -P --name tomcat2 diytomcat</span><br></pre></td></tr></table></figure>

<p>连接容器<code>tomcat1</code>到网络<code>mynet</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect mynet tomcat1</span><br></pre></td></tr></table></figure>

<p>此时，两个方向来ping是可以ping通的了</p>
<p>实际上，tomcat1是被加入到了mynet网络中，这就是一个容器两个ip地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect mynet</span><br></pre></td></tr></table></figure>





<h2 id="4-IDEA-整合-Docker"><a href="#4-IDEA-整合-Docker" class="headerlink" title="4.IDEA 整合 Docker"></a>4.IDEA 整合 Docker</h2><h2 id="5-Docker-Compose-集群管理"><a href="#5-Docker-Compose-集群管理" class="headerlink" title="5.Docker Compose  集群管理"></a>5.Docker Compose  集群管理</h2><h2 id="6-Docker-Swarm-容器编排"><a href="#6-Docker-Swarm-容器编排" class="headerlink" title="6. Docker Swarm 容器编排"></a>6. Docker Swarm 容器编排</h2><h2 id="7-CI-CD-jenkins"><a href="#7-CI-CD-jenkins" class="headerlink" title="7.CI/CD jenkins"></a>7.CI/CD jenkins</h2><h1 id="四、深入理解Docker"><a href="#四、深入理解Docker" class="headerlink" title="四、深入理解Docker"></a>四、深入理解Docker</h1><h3 id="读文档"><a href="#读文档" class="headerlink" title="读文档"></a>读文档</h3><p>1、</p>
<p><img src="Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1674740418153.png" alt="1674740418153"></p>
<p><strong>docker layer 是什么？</strong></p>
<p><a target="_blank" rel="noopener" href="https://naiveskill.com/docker-layer/#:~:text=The%20layer%20in%20a%20dockerfile%20is%20the%20intermediate,layer%20represents%20an%20instruction%20in%20the%20Dockerfile%20image.">What is docker layer? importance of docker layer while creating Dockerfile (naiveskill.com)</a></p>
<p>看完这篇文章后我的简单理解：docker layer 是 dockerfiles 创建时的每一层，每一层对应完成fockerfiles的一个动作，dockerfiles总的来看分成了两个动作：<strong>base image</strong>；<strong>基于base image的layers</strong></p>
<p><img src="Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1674740633100.png" alt="1674740633100"></p>
<p>层数越多，所占用的空间就越多，因此可以通过减少层数来降低所占用的空间</p>
<h1 id="五、项目练习"><a href="#五、项目练习" class="headerlink" title="五、项目练习"></a>五、项目练习</h1><h2 id="1-Docker-部署Nginx"><a href="#1-Docker-部署Nginx" class="headerlink" title="1 Docker 部署Nginx"></a><strong>1 Docker 部署Nginx</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">1 搜索nginx： a.docker search   b.到 docker hub 上搜索</span></span><br><span class="line">https://hub.docker.com/_/nginx</span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta"># </span><span class="language-bash">服务器开放3344端口，容器内在80端口，通过公网3344可以访问到容器内部</span></span><br><span class="line">docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line"><span class="meta"># </span><span class="language-bash">运行测试</span></span><br><span class="line">curl localhost:3344</span><br><span class="line"><span class="meta"># </span><span class="language-bash">进入容器</span></span><br><span class="line">docker exec -it nginx01 /bin/bash</span><br><span class="line"><span class="meta"># </span><span class="language-bash">找nginx的配置文件位置(有很多，都是做什么的呢？)</span></span><br><span class="line">whereis nginx</span><br><span class="line">cd /etc/nginx</span><br><span class="line"><span class="meta"># </span><span class="language-bash">其中 nginx.conf 使nginx的配置文件</span></span><br></pre></td></tr></table></figure>



<p>问题：每次改动nginx配置文件都一定需要进入容器吗？—&gt;数据卷</p>
<h2 id="2-使用docker来装一个tomcat"><a href="#2-使用docker来装一个tomcat" class="headerlink" title="2 使用docker来装一个tomcat"></a><strong>2 使用docker来装一个tomcat</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm tomcat:9.0</span><br><span class="line"><span class="meta"># </span><span class="language-bash">--<span class="built_in">rm</span>参数，用完即删</span></span><br><span class="line"></span><br><span class="line">docker pull tomcat</span><br><span class="line">docker run -d -p 8080:8080 tomcat:latest</span><br><span class="line"><span class="meta"># </span><span class="language-bash">指定开放的端口后，外网可以访问到，但提示404，因为官方所给的tomcat不是完整版</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">进入容器</span></span><br><span class="line">docker exec -it b9b74f7a705d /bin/bash</span><br><span class="line"><span class="meta"># </span><span class="language-bash">发现问题：1 Linux命令少了  2 没有webapps</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">阿里云镜像原因，默认为最小镜像，所有不必要的都剔除掉</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">将webapps.dist 复制过去就可以访问了</span></span><br><span class="line">cp -r webapps.dist/* webapps</span><br></pre></td></tr></table></figure>



<h2 id="3-部署-es-kibana"><a href="#3-部署-es-kibana" class="headerlink" title="3 部署 es + kibana"></a><strong>3 部署 es + kibana</strong></h2><p><a target="_blank" rel="noopener" href="https://hub.docker.com/_/elasticsearch">elasticsearch - Official Image | Docker Hub</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">es 暴露的端口很多</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">es 十分耗内存</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">es 的数据一般要放在安全目录，挂载</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">--net somenetwork 网络配置</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动</span></span><br><span class="line">完整版命令：docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:tag</span><br><span class="line"></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:8.6.1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">验证安装成功</span></span><br><span class="line">curl localhost:9200</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看cpu状态</span></span><br><span class="line">docker stats</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">过于占用内存，直接卡死了，修改配置文件，-e修改环境</span></span><br><span class="line">docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:8.6.1</span><br></pre></td></tr></table></figure>



<h2 id="4-安装并挂载mysql"><a href="#4-安装并挂载mysql" class="headerlink" title="4 安装并挂载mysql"></a><strong>4 安装并挂载mysql</strong></h2><p><a target="_blank" rel="noopener" href="https://hub.docker.com/_/mysql">mysql - Official Image | Docker Hub</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">1 拉取镜像</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="meta"># </span><span class="language-bash">2 挂载镜像，注意mysql需要设置密码</span></span><br><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br><span class="line"><span class="meta"># </span><span class="language-bash">增加多个挂载版本的命令</span></span><br><span class="line">docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动成功后即可访问</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">容器删除，本机上挂载的数据依旧存在</span></span><br></pre></td></tr></table></figure>



<h2 id="5-DockerFile-构建镜像"><a href="#5-DockerFile-构建镜像" class="headerlink" title="5 DockerFile 构建镜像"></a><strong>5 DockerFile 构建镜像</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建一个文件夹</span></span><br><span class="line">mkdir dockerfile</span><br><span class="line">cd dockerfile</span><br><span class="line">vim mydockerfile-centos</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">填写构建镜像内容</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">基础镜像centos，设置环境变量和工作路径，开放80端口，安装vim。net工具</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">因为centos已经停止维护了，所以运行到 yum install 这里会卡住，需要加上修改镜像源的命令，yum makecache这一步会很慢，我更了大概有4分钟多，需要耐心等待。</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">但是会自动更新版本！最后构建出来的镜像特别大，正在找解决方法(待解决)</span></span><br><span class="line"></span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER abilish&lt;sfy_mx@163.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN cd /etc/yum.repos.d/</span><br><span class="line">RUN sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN yum makecache</span><br><span class="line">RUN yum update -y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">build 构建</span></span><br><span class="line">docker build -f mydockerfile-centos -t mycentos:1.0 .</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看构建好的镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta"># </span><span class="language-bash">运行</span></span><br><span class="line">docker -it mycentos:1.0</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看构建变更历史</span></span><br><span class="line">docker history</span><br></pre></td></tr></table></figure>

<p><strong>问题待解决，镜像换源后如何不自动更新</strong></p>
<h2 id="6-tomcat-镜像"><a href="#6-tomcat-镜像" class="headerlink" title="6 tomcat 镜像"></a>6 tomcat 镜像</h2><p>1、准备镜像文件 tomcat压缩包，jdk的压缩包</p>
<p><code>jdk-8u151-linux-x64.tar.gz</code></p>
<p><code>apache-tomcat-9.0.72.tar.gz</code></p>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1Zbe2JcOVYX-b1YPQhL3cgw?pwd=8888">https://pan.baidu.com/s/1Zbe2JcOVYX-b1YPQhL3cgw?pwd=8888</a><br>提取码：8888 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch readme.txt</span><br></pre></td></tr></table></figure>



<p>2、编写dockerfile文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Dockerfile 是官方命名，build时会自动找这个名字的文件，不用指定-f参数了</span></span><br><span class="line">vim Dockerfile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Dockerfile 文件中的内容，ADD后会自动解压文件</span></span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER abilish&lt;sfy_mx@163.com&gt;</span><br><span class="line"></span><br><span class="line">COPY readme.txt /usr/local/readme.txt</span><br><span class="line"></span><br><span class="line">ADD jdk-8u151-linux-x64.tar.gz /usr/local/</span><br><span class="line">ADD apache-tomcat-9.0.72.tar.gz /usr/local/</span><br><span class="line"></span><br><span class="line">RUN cd /etc/yum.repos.d/</span><br><span class="line">RUN sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN yum makecache</span><br><span class="line">RUN yum update -y</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_151</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.72</span><br><span class="line">ENV CATALINE_BASE /usr/local/apache-tomcat-9.0.72</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.72/bin/startup.sh &amp;&amp; tail -F /url/local/apache-tomcat-9.0.72/bin/logs/catal</span><br><span class="line">ina.out</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">构建镜像</span></span><br><span class="line">docker build -t diytomcat .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">运行镜像</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">挂载目录是上面存放jdk、apache等文件目录下的目录</span></span><br><span class="line">docker run -d -p 9090:8080 --name abilishtomcat -v /home/tomcat-jdk/test:/usr/local/apache-tomcat-9.0.72/webapps/test -v /home/tomcat-jdk/tomcatlogs/:/usr/local/apache-tomcat-9.0.72/logs diytomcat</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">进入容器</span></span><br><span class="line">docker exec -it 镜像id /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">访问 ip:9090</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">发布项目(由于做了卷挂载，直接在本地编写项目就可以发布了)</span></span><br><span class="line">cd /home/tomcat-jdk/test</span><br><span class="line">mkdir WEB-INF</span><br><span class="line">cd WEB-INF</span><br><span class="line">vim web.xml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">写入</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</span><br><span class="line">    xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span><br><span class="line">    id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/web-app&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">cd</span> 到上一层目录</span></span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">vim index.jsp</span><br><span class="line"></span><br><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;啦啦啦啦啦&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">Hello World!&lt;br/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">System.out.println(&quot;---my test web log---&quot;);</span><br><span class="line"><span class="meta">%</span><span class="language-bash">&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">访问 ip地址:9090/test/</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看日志是否打印出来了</span></span><br><span class="line">cd ..</span><br><span class="line">cat catalina.out</span><br><span class="line"><span class="meta"># </span><span class="language-bash">可以看到输出的 ---my <span class="built_in">test</span> web <span class="built_in">log</span>---  日志</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">项目部署成功并且能成功访问</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">发布镜像</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">发布到官方镜像库中</span></span><br><span class="line">1 注册自己的账号：https://hub.docker.com/</span><br><span class="line">2 确定账号可以登录</span><br><span class="line">3 在服务器上提交镜像</span><br><span class="line">docker login --help</span><br><span class="line"><span class="meta">	# </span><span class="language-bash">常用参数</span></span><br><span class="line">		-u 指定昵称</span><br><span class="line">		-p 指定密码</span><br><span class="line"></span><br><span class="line">4 登录后 docker push</span><br><span class="line">docker tag 镜像id 用户名(账号名)/仓库名:版本号</span><br><span class="line">docker tag diytomcat xxx/diytomcat:version1.0</span><br><span class="line"></span><br><span class="line">docker push 用户名(账号名)/仓库名:版本号</span><br><span class="line">docker push xxx/diytomcat:version1.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">发布到阿里云镜像库中</span></span><br><span class="line">登录阿里云，找到容器镜像服务，创建个人实例后，找到命名空间，创建一个命名空间；创建容器镜像，仓库信息选择本地仓库</span><br><span class="line"></span><br><span class="line">退出登录刚刚登录的账号：docker logout</span><br><span class="line">按照阿里云镜像下面的步骤来登录push即可</span><br></pre></td></tr></table></figure>





<h2 id="7-redis集群部署"><a href="#7-redis集群部署" class="headerlink" title="7 redis集群部署"></a>7 redis集群部署</h2><p><strong>特点</strong>：分片、高可用、负载均衡</p>
<p>当r-m3 挂了，备份 r-s3 会进行替代</p>
<p><img src="Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1678065538739.png" alt="1678065538739"></p>
<p>准备：移除所有容器，防止卡顿</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<p>自定义一个网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create redis --subnet 172.38.0.0/16</span><br></pre></td></tr></table></figure>

<p>通过脚本来创建六个redis配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for port in $(seq 1 6); \</span><br><span class="line">do \</span><br><span class="line">mkdir -p /mydata/redis/node-$&#123;port&#125;/conf</span><br><span class="line">touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">cat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">port 6379 </span><br><span class="line">bind 0.0.0.0</span><br><span class="line">cluster-enabled yes </span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 172.38.0.1$&#123;port&#125;</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br><span class="line">EOF</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /mydata/</span><br></pre></td></tr></table></figure>



<p>启动容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6371:6379 -p 16371:16379 --name redis-1 \</span><br><span class="line">    -v /mydata/redis/node-1/data:/data \</span><br><span class="line">    -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">    -d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>
            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Docker/" rel="tag">Docker</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/%E5%88%9B%E4%BD%9C%E4%B8%AD/" rel="tag">创作中</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/03/10/%E5%88%9D%E8%AF%86Nginx/"
                    data-tooltip="初识Nginx"
                    aria-label="上一篇: 初识Nginx"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/01/31/resolve-%E6%96%B9%E6%B3%95/"
                    data-tooltip=".resolve()方法"
                    aria-label="下一篇: .resolve()方法"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
                    title="分享到 Google+"
                    aria-label="分享到 Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2023 Abilish. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/03/10/%E5%88%9D%E8%AF%86Nginx/"
                    data-tooltip="初识Nginx"
                    aria-label="上一篇: 初识Nginx"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/01/31/resolve-%E6%96%B9%E6%B3%95/"
                    data-tooltip=".resolve()方法"
                    aria-label="下一篇: .resolve()方法"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
                    title="分享到 Google+"
                    aria-label="分享到 Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=http://example.com/2023/03/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
                        aria-label="分享到 Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>分享到 Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.png" alt="作者的图片"/>
        
            <h4 id="about-card-name">Abilish</h4>
        
            <div id="about-card-bio"><p>Less is More.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p><a href="mailto:&#x73;&#x66;&#x79;&#95;&#x6d;&#120;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;">&#x73;&#x66;&#x79;&#95;&#x6d;&#120;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;</a></p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                China, Heilongjiang
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/bg.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-u4gocod02ukvjjitb63sjkl6iu1qjp8lpnsrzttfhzhhifp6ao9kpwvy9cik.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
